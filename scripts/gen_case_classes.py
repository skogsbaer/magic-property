#!/usr/bin/python

# The gen-case-classes script takes a .h file and an optional .m file. It
# parses all @property definitions from the .h file and inserts
# appropriate @property definitions as well as init, copy, default value
# methods into the .m file (creating an empty .m file if it does not
# exist).
#
# The syntax of @property definitions is standard, with two exceptions:
#
# - Either the 'readonly' or the 'readwrite' option are mandatory.
#
# - The 'default=SOME_LITERAL' option specifies a default value for the property.
#   The '=SOME_LITERAL' part can be omitted, in this case a method of the form
#
#      + (TYPE)NAMEDefault { return ... }
#
#    is expected to be present in the .m file.

import sys
import os
import os.path
import stat
import re
import time
import airspeed # templating system
from magic_utils import *

DOUBLE_TYPES = ['double', 'float', 'NSTimeInterval', 'CGFloat']

INT_TYPES = {'int': 'MPInteger',
             'long': 'MPInteger',
             'NSInteger': 'MPInteger',
             'NSUInteger': 'MPUInteger',
             'long long': 'MPInteger64',
             'uint64_t': 'MPUInteger64'}

globalCustomIntTypes = []

HEADER_LINE = '// Generated by gen-case-classes. DO NOT EDIT!!'

def filter_by_ext(files, ext):
    return [x for x in files if x.endswith(ext)]

def replace_ext(fname, new_ext):
    return os.path.splitext(fname)[0] + new_ext

class CommonEqualityMixin(object):
    def __eq__(self, other):
        return (type(other) is type(self) and self.__dict__ == other.__dict__)
    def __ne__(self, other):
        return not self.__eq__(other)

class Interface(CommonEqualityMixin):
    def __init__(self, loc, name, baseClass, protos, pre_lines):
        self.loc = loc
        self.name = name
        self.baseClass = baseClass
        self.protocols = protos
        self.props = []
        self.lines = []
        self.pre_lines = pre_lines
    def add_property(self, prop):
        self.props.append(prop)
    def add_line(self, line):
        self.lines.append(line)
    def check(self):
        for p in self.props:
            p.check()
    def canNSCoding(self):
        for p in self.props:
            if p.nsCodingTarget() == 'no_serialize':
                return False
        return True
    def __repr__(self):
        return 'Interface(%s, %r, %s, %s, %s)' % (self.loc, self.name, self.props, self.pre_lines, self.lines)

class Implementation(CommonEqualityMixin):
    def __init__(self, loc, name, is_ext, pre_lines, lines):
        self.loc = loc
        self.name = name
        self.lines = lines
        self.pre_lines = pre_lines
        self.is_ext = is_ext
    def add_line(self, line):
        self.lines.append(line)
    def __repr__(self):
        return 'Implementation(%s, %r, %s, %s, %s)' % (self.loc, self.name, self.is_ext, self.pre_lines, self.lines)

def is_pointer_type(t, clazz):
    r = re.compile(clazz + '\s*\*')
    return r.match(t) is not None

class Property(CommonEqualityMixin):
    def __init__(self, loc, opts, typ, name, has_def, def_val):
        self.loc = loc
        self.opts = opts
        self.typ = typ
        self.name = name
        self.has_def = has_def
        self.def_val = def_val
    def __repr__(self):
        return 'Property(%s, %s, %r, %r, %s, %r)' % \
               (self.loc, self.opts, self.typ, self.name, self.has_def, self.def_val)
    def is_read_only(self):
        return 'readonly' in self.opts
    def is_read_write(self):
        return not self.is_read_only()
    def mk_writeable(self):
        opts = [x for x in self.opts if x != 'readonly']
        if 'readwrite' not in opts:
            opts.append('readwrite')
        return Property(self.loc, opts, self.typ, self.name, self.has_def, self.def_val)
    def has_default_value(self):
        return self.def_val is not None
    def default_value(self):
        return self.def_val
    def has_default(self):
        return self.has_def
    def name_default(self):
        return self.name + 'Default'
    def declaration(self):
        return '@property (%s) %s %s;' % (','.join(self.opts), self.typ, self.name)
    def read_write_declaration(self):
        return self.mk_writeable().declaration()
    def name_upper(self):
        return self.name[0].upper() + self.name[1:]
    def name_param(self):
        return '__' + self.name
    def nsCodingTarget(self):
        t = self.typ
        if is_pointer_type(t, 'NSString'): return 'Object'
        if is_pointer_type(t, 'NSData'): return 'Object'
        if t == 'NSInteger': return 'Integer'
        if t == 'NSUInteger': return 'Integer'
        if t == 'int': return 'Integer'
        if t == 'long long': return 'Int64'
        if t == 'uint64_t': return 'Int64'
        if t in globalCustomIntTypes: return 'Integer'
        if t in DOUBLE_TYPES: return 'Double'
        if t == 'BOOL': return 'Integer'
        if t == 'CGPoint': return 'no_serialize'
        if t == 'CGRect': return 'no_serialize'
        if t == 'CGSize': return 'no_serialize'
        if t == 'SEL': return 'no_serialize'
        return 'use_coder'
    def fr_type(self):
        t = self.typ
        if t == 'SEL': return 'MPSelector'
        if t in DOUBLE_TYPES: return 'MPDouble'
        if INT_TYPES.has_key(t): return INT_TYPES[t]
        if t in globalCustomIntTypes: return 'MPInteger' + t
        if t == 'BOOL': return 'MPBool'
        if t == 'CGPoint': return 'MPPoint'
        if t == 'CGRect': return 'MPRect'
        if t == 'CGSize': return 'MPSize'
        if is_pointer_type(t, 'NSString'): return 'MPString'
        if is_pointer_type(t, 'NSData'): return 'MPData'
        return 'MPObject'
    def check(self):
        if 'readwrite' not in self.opts and 'readonly' not in self.opts:
            abort('%s: Property %s must be declared as "readwrite" or "readonly"' % (self.loc, self.name))

class Location(CommonEqualityMixin):
    def __init__(self, file, line):
        self.file = file
        self.line = line
    def __repr__(self):
        return '%s:%d' % (self.file, self.line)
    def next_line(self):
        return Location(self.file, self.line + 1)

noLocation = Location('<no-location>', 0)

class Enum(CommonEqualityMixin):
    def __init__(self, name, alts):
        self.name = name
        self.alts = alts

class EnumAlt(CommonEqualityMixin):
    def __init__(self, enum_name, simple_name, value):
        self.name = enum_name + simple_name
        self.value = value

str_lit_regex = r'@"([^"\\]|\\.)*"'
other_lit_regex = r'[a-zA-Z_0-9.-]+'
lit_regex = r'(%s)|(%s)' % (str_lit_regex, other_lit_regex)
default_val_regex = re.compile(r'(,\s*)?default=((?P<default_val>%s))?(\s*,)?' % lit_regex)
baseClass_proto_regex = r'(\s*:\s*(?P<iface_baseClass>\w+)\s*(<(?P<iface_protocols>[\w,\s]+)>)?)?'
iface_regex = re.compile(r'^@interface\s+(?P<iface_name>\w+)%s' % baseClass_proto_regex)
prop_opts_regex = r'\((?P<prop_opts>[, a-zA-Z0-9]+)\)'
prop_type_regex = r'(?P<prop_type>.+?)'
prop_name_regex = r'(?P<prop_name>\w+)'
prop_regex = re.compile(r'^@property\s*%s%s%s\s*;\s*$' % (prop_opts_regex,
                                                          prop_type_regex,
                                                          prop_name_regex))
impl_regex = re.compile(r'@implementation\s+(?P<iface_name>\w+)')
anon_ext_regex = re.compile(r'@interface\s+(?P<iface_name>\w+)\s*\(\)')

def match_line(loc, line, regex, prefix, what, orig_line=None):
    if orig_line is None:
        orig_line = line
    if line.startswith(prefix):
        m = regex.match(line)
        if m is None:
            abort('%s: Invalid %s\n%s' % (loc, what, orig_line))
        return m
    else:
        return None

def parse_iface_line(loc, line):
    m = match_line(loc, line, iface_regex, '@interface', 'interface definition')
    if m is None:
        return (None, None, [])
    else:
        protos = []
        if m.group('iface_protocols') is not None:
            protos = m.group('iface_protocols').split(",")

        return (m.group('iface_name'), m.group('iface_baseClass'), protos)

def parse_prop_line(loc, orig_line):
    if not orig_line.startswith('@property'):
        return None
    else:
        has_default = False
        default_val = None
        def_m = default_val_regex.search(orig_line)
        if def_m:
            has_default = True
            g = def_m.group('default_val')
            if g:
                default_val = g.strip()
            i = def_m.start()
            j = def_m.end()
            whole = def_m.group(0).strip()
            repl = ''
            if whole.startswith(',') and whole.endswith(','):
                repl = ','
            line = orig_line[:i] + repl + orig_line[j:]
        else:
            line = orig_line
        m = match_line(loc, line, prop_regex, '@property', 'property definition', orig_line=orig_line)
        if m is None:
            return None
        opts_list = [x.strip() for x in m.group('prop_opts').split(',')]
        ty = m.group('prop_type').strip()
        prop = Property(loc, opts_list, ty, m.group('prop_name'), has_default, default_val)
        return (prop, line)

def parse_impl_line(loc, line):
    m = match_line(loc, line, impl_regex, '@implementation', 'implementation definition')
    if m is None:
        m = match_line(loc, line, anon_ext_regex, '@interface', 'anonymous extension definition')
        if m is None:
            return None
        is_ext = True
    else:
        is_ext = False
    return (m.group('iface_name'), is_ext)

def parse_h_file(h, lines):
    """Returns a pair (ifaces, post_lines) where ifaces is a list of Interface instances
    and post_lines are the lines after the last interface."""
    ifaces = []
    current_iface = None
    pre_lines = []
    loc = Location(h, 0)
    for line in lines:
        loc = loc.next_line()
        (iface_name, iface_baseClass, iface_proto) = parse_iface_line(loc, line)

        prop_and_mod_line = parse_prop_line(loc, line)
        if iface_name:
            if iface_baseClass is None:
                abort('Interface %s has no BaseClass?!' % iface_name)

            current_iface = Interface(loc, iface_name, iface_baseClass, iface_proto, pre_lines)

            pre_lines = []
        if prop_and_mod_line:
            (prop, mod_line) = prop_and_mod_line
            if current_iface is None:
                abort('%s: Property definition outside of interface' % loc)
            else:
                current_iface.add_property(prop)
            line = mod_line
        if current_iface is not None:
            current_iface.add_line(line)
        else:
            pre_lines.append(line)
        if line.startswith('@end') and current_iface is not None:
            ifaces.append(current_iface)
            current_iface = None
    return (ifaces, pre_lines)

def parse_m_file(m, lines):
    """Returns a pair (impls, post_lines) where ifaces is a list of Implementation instances
    and post_lines are the lines after the last implementation."""
    impls = []
    current_impl = None
    pre_lines = []
    loc = Location(m, 0)
    for line in lines:
        loc = loc.next_line()
        iface_name_is_ext = parse_impl_line(loc, line)
        if iface_name_is_ext:
            (iface_name, is_ext) = iface_name_is_ext
            current_impl = Implementation(loc, iface_name, is_ext, pre_lines, [])
            pre_lines = []
        if current_impl is not None:
            current_impl.add_line(line)
        else:
            pre_lines.append(line)
        if line.startswith('@end') and current_impl is not None:
            impls.append(current_impl)
            current_impl = None
    return (impls, pre_lines)

h_template = airspeed.Template("""
- (id)initWith${init_params};
+ ($name *)newWith${init_params};
#if (${has_defaults})
- (id)initWith${init_default_params};
+ ($name *)newWith${init_default_params};
#end

#foreach ($p in $props)
- ($name *)copyWith${p.name_upper()}:(${p.typ})${p.name_param()};
#if (${p.has_default()})
+ (${p.typ})${p.name_default()};
#end
#end
""")

ext_template = airspeed.Template("""
#foreach ($p in $props)
  #if (${p.is_read_only()})
${p.read_write_declaration()}
  #end
#end
""")

impl_template = airspeed.Template("""
- (id)initWith${init_params} {
    if ((self = [super init])) {
#foreach ($p in $props)
        self->_${p.name} = ${p.name_param()};
#end
    }
    return self;
}

+ ($name *)newWith${init_params} {
    $name *o = [[$name alloc] init];
    if (o != nil) {
#foreach ($p in $props)
        o->_${p.name} = ${p.name_param()};
#end
    }
    return o;
}

- (id)copyWithZone:(NSZone *)zone {
    return self;
}

#if (${has_defaults})
- (id)initWith${init_default_params} {
    if ((self = [super init])) {
#foreach ($p in $props)
  #if (${p.has_default()})
        self->_${p.name} = [$name ${p.name_default()}];
  #else
        self->_${p.name} = ${p.name_param()};
  #end
#end
    }
    return self;
}

+ ($name *)newWith${init_default_params} {
    $name *o = [[$name alloc] init];
    if (o != nil) {
#foreach ($p in $props)
  #if (${p.has_default()})
        o->_${p.name} = [$name ${p.name_default()}];
  #else
        o->_${p.name} = ${p.name_param()};
  #end
#end
    }
    return o;
}
#end

#foreach ($p in $props)
- ($name *)copyWith${p.name_upper()}:(${p.typ})${p.name_param()} {
    return [[$name alloc] initWith${init_args(${p.name})}];
}

 #if (${p.has_default_value()})
+ (${p.typ})${p.name_default()} {
    return (${p.default_value()});
}
  #end

#end

#if (${nscoding})
- (void)encodeWithCoder:(NSCoder*)encoder {
#foreach ($p in $props)
   #if (${p.nsCodingTarget()} == 'use_coder')
   [encoder encodeObject:[NSKeyedArchiver archivedDataWithRootObject:self->_${p.name}] forKey:@"${p.name}"];
   #else
   [encoder encode${p.nsCodingTarget()}:self->_${p.name} forKey:@"${p.name}"];
   #end
#end
}

- (id) initWithCoder:(NSCoder*)decoder {
    if (self = [super init]) {
    #foreach ($p in $props)
      #if (${p.nsCodingTarget()} == 'use_coder')
      self->_${p.name} = [NSKeyedUnarchiver unarchiveObjectWithData:[decoder decodeObjectForKey:@"${p.name}"]];
      #else
      self->_${p.name} = [decoder decode${p.nsCodingTarget()}ForKey:@"${p.name}"];
    #end
    #end
    }
    return self;
}
#end

${eq_hash_descr_macro}${props_len}($name,#foreach ($p in $props)
    ${p.fr_type()}, ${p.name}#if( $velocityHasNext ), #end
#end
);
""")

def tmpl_args(iface, eq_hash_descr_macro):
    props = iface.props
    init_params = ' '.join(['%s:(%s)%s' % (p.name_upper() if p == props[0] else p.name,
                                           p.typ,
                                           p.name_param())
                            for p in iface.props])
    def_props = [p for p in iface.props if not p.has_default()]
    if def_props:
        init_default_params = ' '.join(['%s:(%s)%s' % (p.name_upper() if p == def_props[0] else p.name,
                                                       p.typ,
                                                       p.name_param())
                                        for p in def_props])
    else:
        init_default_params = 'Defaults'
    def init_args(arg_name):
        return ' '.join(['%s:%s' % (p.name_upper() if p == props[0] else p.name,
                                    p.name_param() if p.name == arg_name else ('self->_' + p.name))
                         for p in props])
    return {'name': iface.name,
            'props': props,
            'props_len': len(props),
            'eq_hash_descr_macro': eq_hash_descr_macro,
            'init_params': init_params,
            'init_default_params': init_default_params,
            'init_args': init_args,
            'nscoding': iface.canNSCoding(),
            'has_defaults': len(def_props) < len(iface.props)}

def gen_impl_def(iface, ext_opt, impl_opt, eq_hash_descr_macro):
    def f(opt, is_ext, lines, tmpl):
        x = opt or Implementation(loc=noLocation, name=iface.name, is_ext=is_ext,
                                  pre_lines=[], lines=lines)
        if len(iface.props) > 0:
            code = tmpl.merge(tmpl_args(iface, eq_hash_descr_macro))
        else:
            code = ''
        lines = x.pre_lines + x.lines[:-1] + [code, x.lines[-1]]
        return '\n'.join(lines)
    ext_code = f(ext_opt, True, ['@interface %s ()' % iface.name, '@end'],
                 ext_template)
    impl_code = f(impl_opt, False, ['@implementation %s' % iface.name, '@end'],
                  impl_template)
    return ext_code + '\n' + impl_code

def gen_iface_def(iface, eq_hash_descr_macro):
    if len(iface.props) > 0:
        extra_content = h_template.merge(tmpl_args(iface, eq_hash_descr_macro))
    else:
        extra_content = ''
    lines = iface.pre_lines + iface.lines[:-1] + [extra_content, iface.lines[-1]]
    add = ["NSCopying"]
    if iface.canNSCoding():
        add = add + ["NSCoding"]
    else:
        warn("Can't generate NSCoding for " + iface.name)

    # find @interface line
    for x in range(0, len(lines) - 1):
        if (lines[x].startswith("@interface") and (not lines[x].startswith("@interface MPInteger"))) and (len(iface.props) > 0):
            lines[x] = '@interface ' + iface.name + ' : ' + iface.baseClass

            allProtos = iface.protocols + add
            if len(allProtos) > 0:
                lines[x] += ' <' + (', '.join(allProtos)) + '>'

    return '\n'.join(lines)

def genfile(content, fname):
    if os.path.exists(fname):
        for l in open(fname).readlines():
            if l.strip() != HEADER_LINE:
                abort('Refusing to overwrite file %s. It does not seem to be a file generated by this program.' % fname)
            break
        os.chmod(fname, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP)
    f = open(fname, 'w')
    date = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    f.write('%s\n// Generated at %s\n\n' % (HEADER_LINE, date))
    f.write(content)
    f.close()
    os.chmod(fname, stat.S_IRUSR | stat.S_IRGRP)

def mk_outfile_name(in_name, output_dir, ext):
    base = replace_ext(os.path.basename(in_name), ext)
    return os.path.join(output_dir, base)

def get_lines(f):
    return [(l[:-1] if l and l[-1] == '\n' else l) for l in open(f).readlines()]

def gencode_for_file(h, m_opt, output_dir, eq_hash_descr_header, eq_hash_descr_macro):
    h_lines = get_lines(h)
    (ifaces, h_post_lines) = parse_h_file(h, h_lines)
    if m_opt is not None:
        m_lines = get_lines(m_opt)
        (impls, m_post_lines) = parse_m_file(m_opt, m_lines)
    else:
        impls = []
        m_post_lines = []
    h_content = ''
    m_imports = [os.path.basename(h), eq_hash_descr_header, 'MPEqHashDescriptionGenerator.h']
    m_content = ''.join(['#import "%s"\n' % x for x in m_imports])
    for iface in ifaces:
        iface.check()
        h_content += gen_iface_def(iface, eq_hash_descr_macro) + '\n'
        def find_impl(is_ext):
            for x in impls:
                if x.is_ext == is_ext and x.name == iface.name:
                    return x
            return None
        ext_opt = find_impl(True)
        impl_opt = find_impl(False)
        m_content += gen_impl_def(iface, ext_opt, impl_opt, eq_hash_descr_macro) + '\n'
    h_content += '\n'.join(h_post_lines)
    genfile(h_content, mk_outfile_name(h, output_dir, '.h'))
    genfile(m_content, mk_outfile_name(h, output_dir, '.m'))

def load_enums(enum_file):
    lines = parse_linesep_file(enum_file)
    lineno = 0
    enums = []
    for line in lines:
        lineno = lineno + 1
        i = line.find(':')
        if i <= 0:
            abort('Invalid enum definition at %s:%d. Each enum definition has the form\n'
                  'ENUM_TYPE: ENUM_ALT_1 ENUM_ALT_2 ...' % (enum_file, lineno))
        ty = line[:i].strip()
        rest = line[i+1:]
        i = 1
        alts_with_values = []
        for a in rest.split(' '):
            a = a.strip()
            if a:
                alts_with_values.append(EnumAlt(ty, a, i))
                i = i + 1
        enums.append(Enum(ty, alts_with_values))
    return enums

enum_h_template = airspeed.Template("""
typedef enum {
#foreach ($a in ${enum.alts})
  ${a.name} = ${a.value},
#end
} ${enum.name};
NSString *stringFrom${enum.name}(${enum.name} x);
@interface MPInteger${enum.name} : MPInteger
+ (NSString *)descriptionOf:(NSInteger)i;
@end
""")

enum_m_template = airspeed.Template("""
NSString *stringFrom${enum.name}(${enum.name} x)
{
    switch (x) {
#foreach ($a in ${enum.alts})
        case ${a.name}: return @"${a.name}";
#end
        default: return [NSString stringWithFormat:@"Unknown${enum.name}(%d)", x];
    }
}
@implementation MPInteger${enum.name}
+ (NSString *)descriptionOf:(NSInteger)i {
    return stringFrom${enum.name}(i);
}
@end
""")

def gencode_for_enums(output_dir, enum_file, eq_hash_descr_header):
    enums = load_enums(enum_file)
    h_content = '#import <Foundation/Foundation.h>\n#import "' + eq_hash_descr_header + '"\n'
    h_name = replace_ext(os.path.basename(enum_file), '.h')
    m_content = '#import "' + h_name + '"\n'
    for e in enums:
        h_content += enum_h_template.merge({'enum': e})
        h_content += '\n'
        m_content += enum_m_template.merge({'enum': e})
        m_content += '\n'
    genfile(h_content, mk_outfile_name(enum_file, output_dir, '.h'))
    genfile(m_content, mk_outfile_name(enum_file, output_dir, '.m'))
    return [e.name for e in enums]

def gencode(input_files, output_dir, enum_file,
            eq_hash_descr_header, eq_hash_descr_macro,
            custom_ints_file):
    if enum_file:
        enums = gencode_for_enums(output_dir, enum_file,
                                  eq_hash_descr_header)
    else:
        enums = []
    global globalCustomIntTypes
    if custom_ints_file:
        custom_ints = parse_linesep_file(custom_ints_file)
    else:
        custom_ints = []
    globalCustomIntTypes = custom_ints + enums
    hFiles = filter_by_ext(input_files, '.h')
    mFiles = filter_by_ext(input_files, '.m')
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    for h in hFiles:
        m = replace_ext(h, '.m')
        has_m = m in mFiles
        if has_m:
            code_for = "%s/%s" % (h, m)
        else:
            code_for = h
        info("Generating code for " + code_for)
        m_opt = m if has_m else None
        gencode_for_file(h, m_opt, output_dir,
                         eq_hash_descr_header,
                         eq_hash_descr_macro)
        info("Done generating code for " + code_for)

#
# TESTS
#

import unittest

h_file = r"""// FOO
// BAR
@interface Foo : NSObject <Baz>

@property (default=@"Hello \"Stefan\"\n", nonatomic, strong, readonly) NSString *p1;
@property (nonatomic, strong, readwrite) int p2;
@property (nonatomic, weak, default=1.2) id<MyObserver> p3;
@property (nonatomic, default=, weak) NSObject<MyObserver> *  p4;
@property (nonatomic, strong, readonly) NSString *defaultUser;

- (void)someMethod:(int)i withString:(NSString *)s;
@end
// REST
"""

class GeneratorTest(unittest.TestCase):
    def test_parse_h_file(self):
        def loc(i):
            return Location('<string>', i)
        exp = [Property(loc(5), ['nonatomic', 'strong', 'readonly'], 'NSString *', 'p1',
                        True, r'@"Hello \"Stefan\"\n"'),
               Property(loc(6), ['nonatomic', 'strong', 'readwrite'], 'int', 'p2', False, None),
               Property(loc(7), ['nonatomic', 'weak'], 'id<MyObserver>', 'p3', True, '1.2'),
               Property(loc(8), ['nonatomic', 'weak'], 'NSObject<MyObserver> *', 'p4', True, None),
               Property(loc(9), ['nonatomic', 'strong', 'readonly'], 'NSString *', 'defaultUser', False, None)]
        (ifaces, post_lines) = parse_h_file('<string>', h_file.split('\n'))
        self.assertEqual(post_lines, ['// REST', ''])
        self.assertEqual(len(ifaces), 1)
        iface = ifaces[0]
        self.assertEqual(iface.name, 'Foo')
        self.assertEqual(iface.pre_lines, ['// FOO', '// BAR'])
        self.assertEqual(iface.props, exp, '\nresult=\n%r\nexpected=\n%r' % (iface.props, exp))

    def test_codegen(self):
        ecode = os.system('scripts/tests/gen-case-classes/run.sh') >> 8
        self.assertEqual(ecode, 0)
#
# MAIN
#

if __name__ == '__main__':
    unittest.main(argv=sys.argv)
